"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
<<<<<<< HEAD
var _utils = require("@typescript-eslint/utils");
var _utils2 = require("./utils");
const isPromiseChainCall = node => {
  if (node.type === _utils.AST_NODE_TYPES.CallExpression && node.callee.type === _utils.AST_NODE_TYPES.MemberExpression && (0, _utils2.isSupportedAccessor)(node.callee.property)) {
    // promise methods should have at least 1 argument
    if (node.arguments.length === 0) {
      return false;
    }
    switch ((0, _utils2.getAccessorValue)(node.callee.property)) {
      case 'then':
        return node.arguments.length < 3;
      case 'catch':
      case 'finally':
        return node.arguments.length < 2;
    }
  }
  return false;
};
const isTestCaseCallWithCallbackArg = (node, context) => {
  const jestCallFn = (0, _utils2.parseJestFnCall)(node, context);
  if ((jestCallFn === null || jestCallFn === void 0 ? void 0 : jestCallFn.type) !== 'test') {
    return false;
  }
  const isJestEach = jestCallFn.members.some(s => (0, _utils2.getAccessorValue)(s) === 'each');
  if (isJestEach && node.callee.type !== _utils.AST_NODE_TYPES.TaggedTemplateExpression) {
    // isJestEach but not a TaggedTemplateExpression, so this must be
    // the `jest.each([])()` syntax which this rule doesn't support due
    // to its complexity (see jest-community/eslint-plugin-jest#710)
    // so we return true to trigger bailout
    return true;
  }
  const [, callback] = node.arguments;
  const callbackArgIndex = Number(isJestEach);
  return callback && (0, _utils2.isFunction)(callback) && callback.params.length === 1 + callbackArgIndex;
};
const isPromiseMethodThatUsesValue = (node, identifier) => {
  const {
    name
  } = identifier;
  if (node.argument === null) {
    return false;
  }
  if (node.argument.type === _utils.AST_NODE_TYPES.CallExpression && node.argument.arguments.length > 0) {
    const nodeName = (0, _utils2.getNodeName)(node.argument);
    if (['Promise.all', 'Promise.allSettled'].includes(nodeName)) {
      const [firstArg] = node.argument.arguments;
      if (firstArg.type === _utils.AST_NODE_TYPES.ArrayExpression && firstArg.elements.some(nod => nod && (0, _utils2.isIdentifier)(nod, name))) {
        return true;
      }
    }
    if (['Promise.resolve', 'Promise.reject'].includes(nodeName) && node.argument.arguments.length === 1) {
      return (0, _utils2.isIdentifier)(node.argument.arguments[0], name);
    }
  }
  return (0, _utils2.isIdentifier)(node.argument, name);
};

/**
 * Attempts to determine if the runtime value represented by the given `identifier`
 * is `await`ed within the given array of elements
 */
const isValueAwaitedInElements = (name, elements) => {
  for (const element of elements) {
    if ((element === null || element === void 0 ? void 0 : element.type) === _utils.AST_NODE_TYPES.AwaitExpression && (0, _utils2.isIdentifier)(element.argument, name)) {
      return true;
    }
    if ((element === null || element === void 0 ? void 0 : element.type) === _utils.AST_NODE_TYPES.ArrayExpression && isValueAwaitedInElements(name, element.elements)) {
      return true;
    }
  }
  return false;
};

/**
 * Attempts to determine if the runtime value represented by the given `identifier`
 * is `await`ed as an argument along the given call expression
 */
const isValueAwaitedInArguments = (name, call) => {
  let node = call;
  while (node) {
    if (node.type === _utils.AST_NODE_TYPES.CallExpression) {
      if (isValueAwaitedInElements(name, node.arguments)) {
        return true;
      }
      node = node.callee;
    }
    if (node.type !== _utils.AST_NODE_TYPES.MemberExpression) {
      break;
    }
    node = node.object;
  }
  return false;
};
const getLeftMostCallExpression = call => {
  let leftMostCallExpression = call;
  let node = call;
  while (node) {
    if (node.type === _utils.AST_NODE_TYPES.CallExpression) {
      leftMostCallExpression = node;
      node = node.callee;
    }
    if (node.type !== _utils.AST_NODE_TYPES.MemberExpression) {
      break;
    }
    node = node.object;
  }
  return leftMostCallExpression;
};

/**
 * Attempts to determine if the runtime value represented by the given `identifier`
 * is `await`ed or `return`ed within the given `body` of statements
 */
const isValueAwaitedOrReturned = (identifier, body, context) => {
  const {
    name
  } = identifier;
  for (const node of body) {
    // skip all nodes that are before this identifier, because they'd probably
    // be affecting a different runtime value (e.g. due to reassignment)
    if (node.range[0] <= identifier.range[0]) {
      continue;
    }
    if (node.type === _utils.AST_NODE_TYPES.ReturnStatement) {
      return isPromiseMethodThatUsesValue(node, identifier);
    }
    if (node.type === _utils.AST_NODE_TYPES.ExpressionStatement) {
      // it's possible that we're awaiting the value as an argument
      if (node.expression.type === _utils.AST_NODE_TYPES.CallExpression) {
        if (isValueAwaitedInArguments(name, node.expression)) {
          return true;
        }
        const leftMostCall = getLeftMostCallExpression(node.expression);
        const jestFnCall = (0, _utils2.parseJestFnCall)(node.expression, context);
        if ((jestFnCall === null || jestFnCall === void 0 ? void 0 : jestFnCall.type) === 'expect' && leftMostCall.arguments.length > 0 && (0, _utils2.isIdentifier)(leftMostCall.arguments[0], name)) {
          if (jestFnCall.members.some(m => {
            const v = (0, _utils2.getAccessorValue)(m);
            return v === _utils2.ModifierName.resolves || v === _utils2.ModifierName.rejects;
          })) {
            return true;
          }
        }
      }
      if (node.expression.type === _utils.AST_NODE_TYPES.AwaitExpression && isPromiseMethodThatUsesValue(node.expression, identifier)) {
        return true;
      }

      // (re)assignment changes the runtime value, so if we've not found an
      // await or return already we act as if we've reached the end of the body
      if (node.expression.type === _utils.AST_NODE_TYPES.AssignmentExpression) {
        var _getNodeName;
        // unless we're assigning to the same identifier, in which case
        // we might be chaining off the existing promise value
        if ((0, _utils2.isIdentifier)(node.expression.left, name) && (_getNodeName = (0, _utils2.getNodeName)(node.expression.right)) !== null && _getNodeName !== void 0 && _getNodeName.startsWith(`${name}.`) && isPromiseChainCall(node.expression.right)) {
          continue;
        }
        break;
      }
    }
    if (node.type === _utils.AST_NODE_TYPES.BlockStatement && isValueAwaitedOrReturned(identifier, node.body, context)) {
      return true;
    }
  }
  return false;
};
const findFirstBlockBodyUp = node => {
  let parent = node;
  while (parent) {
    if (parent.type === _utils.AST_NODE_TYPES.BlockStatement) {
      return parent.body;
    }
    parent = parent.parent;
  }

  /* istanbul ignore next */
  throw new Error(`Could not find BlockStatement - please file a github issue at https://github.com/jest-community/eslint-plugin-jest`);
};
const isDirectlyWithinTestCaseCall = (node, context) => {
  let parent = node;
  while (parent) {
    if ((0, _utils2.isFunction)(parent)) {
      var _parent;
      parent = parent.parent;
      return ((_parent = parent) === null || _parent === void 0 ? void 0 : _parent.type) === _utils.AST_NODE_TYPES.CallExpression && (0, _utils2.isTypeOfJestFnCall)(parent, context, ['test']);
    }
    parent = parent.parent;
  }
  return false;
};
const isVariableAwaitedOrReturned = (variable, context) => {
  const body = findFirstBlockBodyUp(variable);

  // it's pretty much impossible for us to track destructuring assignments,
  // so we return true to bailout gracefully
  if (!(0, _utils2.isIdentifier)(variable.id)) {
    return true;
  }
  return isValueAwaitedOrReturned(variable.id, body, context);
};
var _default = (0, _utils2.createRule)({
=======

var _experimentalUtils = require("@typescript-eslint/experimental-utils");

var _utils = require("./utils");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const isThenOrCatchCall = node => node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(node.callee.property) && ['then', 'catch'].includes((0, _utils.getAccessorValue)(node.callee.property));

const isExpectCallPresentInFunction = body => {
  if (body.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement) {
    return body.body.find(line => {
      if (line.type === _experimentalUtils.AST_NODE_TYPES.ExpressionStatement) {
        return isFullExpectCall(line.expression);
      }

      if (line.type === _experimentalUtils.AST_NODE_TYPES.ReturnStatement && line.argument) {
        return isFullExpectCall(line.argument);
      }

      return false;
    });
  }

  return isFullExpectCall(body);
};

const isFullExpectCall = expression => expression.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && (0, _utils.isExpectMember)(expression.callee);

const reportReturnRequired = (context, node) => {
  context.report({
    loc: {
      end: {
        column: node.loc.end.column,
        line: node.loc.end.line
      },
      start: node.loc.start
    },
    messageId: 'returnPromise',
    node
  });
};

const isPromiseReturnedLater = (node, testFunctionBody) => {
  let promiseName;

  if (node.type === _experimentalUtils.AST_NODE_TYPES.ExpressionStatement && node.expression.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.expression.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(node.expression.callee.object)) {
    promiseName = (0, _utils.getAccessorValue)(node.expression.callee.object);
  } else if (node.type === _experimentalUtils.AST_NODE_TYPES.VariableDeclarator && node.id.type === _experimentalUtils.AST_NODE_TYPES.Identifier) {
    promiseName = node.id.name;
  }

  const lastLineInTestFunc = testFunctionBody[testFunctionBody.length - 1];
  return lastLineInTestFunc.type === _experimentalUtils.AST_NODE_TYPES.ReturnStatement && lastLineInTestFunc.argument && ('name' in lastLineInTestFunc.argument && lastLineInTestFunc.argument.name === promiseName || !promiseName);
};

const isTestFunc = node => node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && (0, _utils.isSupportedAccessor)(node.callee) && [_utils.TestCaseName.it, _utils.TestCaseName.test].includes((0, _utils.getAccessorValue)(node.callee));

const findTestFunction = node => {
  while (node) {
    if ((0, _utils.isFunction)(node) && node.parent && isTestFunc(node.parent)) {
      return node;
    }

    node = node.parent;
  }

  return null;
};

const isParentThenOrPromiseReturned = (node, testFunctionBody) => node.type === _experimentalUtils.AST_NODE_TYPES.ReturnStatement || isPromiseReturnedLater(node, testFunctionBody); // prettier-ignore
// WEB-40105


const verifyExpectWithReturn = (promiseCallbacks, node, context, testFunctionBody) => {
  promiseCallbacks.some(promiseCallback => {
    if (promiseCallback && (0, _utils.isFunction)(promiseCallback) && promiseCallback.body) {
      if (isExpectCallPresentInFunction(promiseCallback.body) && node.parent && node.parent.parent && !isParentThenOrPromiseReturned(node.parent.parent, testFunctionBody)) {
        reportReturnRequired(context, node.parent.parent);
        return true;
      }
    }

    return false;
  });
};

const isHavingAsyncCallBackParam = testFunction => testFunction.params[0] && testFunction.params[0].type === _experimentalUtils.AST_NODE_TYPES.Identifier;

var _default = (0, _utils.createRule)({
>>>>>>> 3593505a2789098f8b7e01cec0412530a8c77294
  name: __filename,
  meta: {
    docs: {
      category: 'Best Practices',
<<<<<<< HEAD
      description: 'Require promises that have expectations in their chain to be valid',
      recommended: 'error'
    },
    messages: {
      expectInFloatingPromise: 'This promise should either be returned or awaited to ensure the expects in its chain are called'
=======
      description: 'Enforce having return statement when testing with promises',
      recommended: 'error'
    },
    messages: {
      returnPromise: 'Promise should be returned to test its fulfillment or rejection'
>>>>>>> 3593505a2789098f8b7e01cec0412530a8c77294
    },
    type: 'suggestion',
    schema: []
  },
  defaultOptions: [],
<<<<<<< HEAD
  create(context) {
    let inTestCaseWithDoneCallback = false;
    // an array of booleans representing each promise chain we enter, with the
    // boolean value representing if we think a given chain contains an expect
    // in it's body.
    //
    // since we only care about the inner-most chain, we represent the state in
    // reverse with the inner-most being the first item, as that makes it
    // slightly less code to assign to by not needing to know the length
    const chains = [];
    return {
      CallExpression(node) {
        // there are too many ways that the done argument could be used with
        // promises that contain expect that would make the promise safe for us
        if (isTestCaseCallWithCallbackArg(node, context)) {
          inTestCaseWithDoneCallback = true;
          return;
        }

        // if this call expression is a promise chain, add it to the stack with
        // value of "false", as we assume there are no expect calls initially
        if (isPromiseChainCall(node)) {
          chains.unshift(false);
          return;
        }

        // if we're within a promise chain, and this call expression looks like
        // an expect call, mark the deepest chain as having an expect call
        if (chains.length > 0 && (0, _utils2.isTypeOfJestFnCall)(node, context, ['expect'])) {
          chains[0] = true;
        }
      },
      'CallExpression:exit'(node) {
        // there are too many ways that the "done" argument could be used to
        // make promises containing expects safe in a test for us to be able to
        // accurately check, so we just bail out completely if it's present
        if (inTestCaseWithDoneCallback) {
          if ((0, _utils2.isTypeOfJestFnCall)(node, context, ['test'])) {
            inTestCaseWithDoneCallback = false;
          }
          return;
        }
        if (!isPromiseChainCall(node)) {
          return;
        }

        // since we're exiting this call expression (which is a promise chain)
        // we remove it from the stack of chains, since we're unwinding
        const hasExpectCall = chains.shift();

        // if the promise chain we're exiting doesn't contain an expect,
        // then we don't need to check it for anything
        if (!hasExpectCall) {
          return;
        }
        const {
          parent
        } = (0, _utils2.findTopMostCallExpression)(node);

        // if we don't have a parent (which is technically impossible at runtime)
        // or our parent is not directly within the test case, we stop checking
        // because we're most likely in the body of a function being defined
        // within the test, which we can't track
        if (!parent || !isDirectlyWithinTestCaseCall(parent, context)) {
          return;
        }
        switch (parent.type) {
          case _utils.AST_NODE_TYPES.VariableDeclarator:
            {
              if (isVariableAwaitedOrReturned(parent, context)) {
                return;
              }
              break;
            }
          case _utils.AST_NODE_TYPES.AssignmentExpression:
            {
              if (parent.left.type === _utils.AST_NODE_TYPES.Identifier && isValueAwaitedOrReturned(parent.left, findFirstBlockBodyUp(parent), context)) {
                return;
              }
              break;
            }
          case _utils.AST_NODE_TYPES.ExpressionStatement:
            break;
          case _utils.AST_NODE_TYPES.ReturnStatement:
          case _utils.AST_NODE_TYPES.AwaitExpression:
          default:
            return;
        }
        context.report({
          messageId: 'expectInFloatingPromise',
          node: parent
        });
      }
    };
  }
});
=======

  create(context) {
    return {
      CallExpression(node) {
        if (!isThenOrCatchCall(node) || node.parent && node.parent.type === _experimentalUtils.AST_NODE_TYPES.AwaitExpression) {
          return;
        }

        const testFunction = findTestFunction(node);

        if (testFunction && !isHavingAsyncCallBackParam(testFunction)) {
          const body = testFunction.body;
          /* istanbul ignore if https://github.com/typescript-eslint/typescript-eslint/issues/734 */

          if (!body) {
            throw new Error(`Unexpected null when attempting to fix ${context.getFilename()} - please file a github issue at https://github.com/jest-community/eslint-plugin-jest`);
          }

          if (body.type !== _experimentalUtils.AST_NODE_TYPES.BlockStatement) {
            return;
          }

          const testFunctionBody = body.body;

          const _node$arguments = _slicedToArray(node.arguments, 2),
                fulfillmentCallback = _node$arguments[0],
                rejectionCallback = _node$arguments[1]; // then block can have two args, fulfillment & rejection
          // then block can have one args, fulfillment
          // catch block can have one args, rejection
          // ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise


          verifyExpectWithReturn([fulfillmentCallback, rejectionCallback], node.callee, context, testFunctionBody);
        }
      }

    };
  }

});

>>>>>>> 3593505a2789098f8b7e01cec0412530a8c77294
exports.default = _default;