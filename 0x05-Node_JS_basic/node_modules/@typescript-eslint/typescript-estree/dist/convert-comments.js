"use strict";
<<<<<<< HEAD
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertComments = void 0;
const util_1 = require("tsutils/util/util");
const ts = __importStar(require("typescript"));
const node_utils_1 = require("./node-utils");
const ts_estree_1 = require("./ts-estree");
=======
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts = __importStar(require("typescript")); // leave this as * as ts so people using util package don't need syntheticDefaultImports
const node_utils_1 = require("./node-utils");
/**
 * Converts a TypeScript comment to an Esprima comment.
 * @param block True if it's a block comment, false if not.
 * @param text The text of the comment.
 * @param start The index at which the comment starts.
 * @param end The index at which the comment ends.
 * @param startLoc The location at which the comment starts.
 * @param endLoc The location at which the comment ends.
 * @returns The comment object.
 * @internal
 */
function convertTypeScriptCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
    const comment = {
        type: block ? 'Block' : 'Line',
        value: text,
    };
    if (typeof start === 'number') {
        comment.range = [start, end];
    }
    if (typeof startLoc === 'object') {
        comment.loc = {
            start: startLoc,
            end: endLoc,
        };
    }
    return comment;
}
/**
 * Convert comment from TypeScript Triva Scanner.
 * @param triviaScanner TS Scanner
 * @param ast the AST object
 * @param code TypeScript code
 * @returns the converted Comment
 * @private
 */
function getCommentFromTriviaScanner(triviaScanner, ast, code) {
    const kind = triviaScanner.getToken();
    const isBlock = kind === ts.SyntaxKind.MultiLineCommentTrivia;
    const range = {
        pos: triviaScanner.getTokenPos(),
        end: triviaScanner.getTextPos(),
        kind: triviaScanner.getToken(),
    };
    const comment = code.substring(range.pos, range.end);
    const text = isBlock
        ? comment.replace(/^\/\*/, '').replace(/\*\/$/, '')
        : comment.replace(/^\/\//, '');
    const loc = node_utils_1.getLocFor(range.pos, range.end, ast);
    return convertTypeScriptCommentToEsprimaComment(isBlock, text, range.pos, range.end, loc.start, loc.end);
}
>>>>>>> 3593505a2789098f8b7e01cec0412530a8c77294
/**
 * Convert all comments for the given AST.
 * @param ast the AST object
 * @param code the TypeScript code
 * @returns the converted ESTreeComment
 * @private
 */
function convertComments(ast, code) {
    const comments = [];
<<<<<<< HEAD
    (0, util_1.forEachComment)(ast, (_, comment) => {
        const type = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia
            ? ts_estree_1.AST_TOKEN_TYPES.Line
            : ts_estree_1.AST_TOKEN_TYPES.Block;
        const range = [comment.pos, comment.end];
        const loc = (0, node_utils_1.getLocFor)(range[0], range[1], ast);
        // both comments start with 2 characters - /* or //
        const textStart = range[0] + 2;
        const textEnd = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia
            ? // single line comments end at the end
                range[1] - textStart
            : // multiline comments end 2 characters early
                range[1] - textStart - 2;
        comments.push({
            type,
            value: code.slice(textStart, textStart + textEnd),
            range,
            loc,
        });
    }, ast);
=======
    /**
     * Create a TypeScript Scanner, with skipTrivia set to false so that
     * we can parse the comments
     */
    const triviaScanner = ts.createScanner(ast.languageVersion, false, ast.languageVariant, code);
    let kind = triviaScanner.scan();
    while (kind !== ts.SyntaxKind.EndOfFileToken) {
        const start = triviaScanner.getTokenPos();
        const end = triviaScanner.getTextPos();
        let container = null;
        switch (kind) {
            case ts.SyntaxKind.SingleLineCommentTrivia:
            case ts.SyntaxKind.MultiLineCommentTrivia: {
                const comment = getCommentFromTriviaScanner(triviaScanner, ast, code);
                comments.push(comment);
                break;
            }
            case ts.SyntaxKind.GreaterThanToken:
                container = node_utils_1.getNodeContainer(ast, start, end);
                if ((container.parent &&
                    container.parent.parent &&
                    // Rescan after an opening element or fragment
                    (container.parent.kind === ts.SyntaxKind.JsxOpeningElement &&
                        // Make sure this is the end of a tag like `<Component<number>>`
                        container.parent.end === end)) ||
                    container.parent.kind === ts.SyntaxKind.JsxOpeningFragment ||
                    // Rescan after a self-closing element if it's inside another JSX element
                    (container.parent.kind === ts.SyntaxKind.JsxSelfClosingElement &&
                        (container.parent.parent.kind === ts.SyntaxKind.JsxElement ||
                            container.parent.parent.kind === ts.SyntaxKind.JsxFragment)) ||
                    // Rescan after a closing element if it's inside another JSX element
                    ((container.parent.kind === ts.SyntaxKind.JsxClosingElement ||
                        container.parent.kind === ts.SyntaxKind.JsxClosingFragment) &&
                        container.parent.parent.parent &&
                        (container.parent.parent.parent.kind === ts.SyntaxKind.JsxElement ||
                            container.parent.parent.parent.kind ===
                                ts.SyntaxKind.JsxFragment))) {
                    kind = triviaScanner.reScanJsxToken();
                    continue;
                }
                break;
            case ts.SyntaxKind.CloseBraceToken:
                container = node_utils_1.getNodeContainer(ast, start, end);
                // Rescan after a JSX expression
                if (container.parent &&
                    container.parent.kind === ts.SyntaxKind.JsxExpression) {
                    kind = triviaScanner.reScanJsxToken();
                    continue;
                }
                if (container.kind === ts.SyntaxKind.TemplateMiddle ||
                    container.kind === ts.SyntaxKind.TemplateTail) {
                    kind = triviaScanner.reScanTemplateToken();
                    continue;
                }
                break;
            case ts.SyntaxKind.SlashToken:
            case ts.SyntaxKind.SlashEqualsToken:
                container = node_utils_1.getNodeContainer(ast, start, end);
                if (container.kind === ts.SyntaxKind.RegularExpressionLiteral) {
                    kind = triviaScanner.reScanSlashToken();
                    continue;
                }
                break;
            default:
                break;
        }
        kind = triviaScanner.scan();
    }
>>>>>>> 3593505a2789098f8b7e01cec0412530a8c77294
    return comments;
}
exports.convertComments = convertComments;
//# sourceMappingURL=convert-comments.js.map